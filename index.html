<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Our Galaxy</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: "Microsoft YaHei", sans-serif; }
        #cover {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(25px); -webkit-backdrop-filter: blur(25px);
            display: flex; justify-content: center; align-items: center;
            z-index: 100; transition: opacity 1.2s ease;
        }
        #start-btn {
            padding: 18px 50px; font-size: 1.3rem; color: white;
            background: rgba(255, 105, 180, 0.4); border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 40px; cursor: pointer; transition: 0.3s;
            box-shadow: 0 0 30px rgba(255, 105, 180, 0.2);
        }
        .modal {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.9);
            width: 85%; max-width: 420px; padding: 30px;
            background: rgba(20, 20, 20, 0.7);
            backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 182, 193, 0.3); border-radius: 24px;
            color: white; text-align: center; opacity: 0; pointer-events: none;
            transition: 0.5s cubic-bezier(0.19, 1, 0.22, 1); z-index: 200;
        }
        .modal.active { opacity: 1; pointer-events: auto; transform: translate(-50%, -50%) scale(1); }
        .modal img { width: 100%; border-radius: 15px; margin-bottom: 15px; }
        .close-btn { margin-top: 20px; cursor: pointer; color: #ffb6c1; font-weight: bold; }
    </style>
</head>
<body>

<div id="cover">
    <button id="start-btn">Touch to start journey</button>
</div>

<div id="modal" class="modal">
    <h2 id="modal-title"></h2>
    <img id="modal-img" src="">
    <p id="modal-text"></p>
    <div class="close-btn" onclick="closeModal()">ç‚¹å‡»æ”¶èµ·</div>
</div>

<script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
</script>

<script type="module">
    import * as THREE from 'three';

    let scene, camera, renderer, particles, starField;
    const particleCount = 20000;
    const targetPositions = new Float32Array(particleCount * 3);
    const currentPositions = new Float32Array(particleCount * 3);
    let isStarted = false;
    const group = new THREE.Group();
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    const contentData = {
        'çŒ«': { emoji: 'ğŸˆ', title: 'çµåŠ¨å¦‚ä½ ', text: 'ä½ æ˜¯è—åœ¨æ˜Ÿå…‰é‡Œçš„çŒ«ï¼Œå¶å°”è°ƒçš®ï¼Œæ°¸è¿œæ²»æ„ˆã€‚', img: '5.jpg' },
        'ç‹—': { emoji: 'ğŸ•', title: 'å¿ è¯šå®ˆæŠ¤', text: 'åƒå¿ çŠ¬ä¸€æ ·ï¼Œæˆ‘çš„ç›®å…‰æ°¸è¿œè¿½éšä½ çš„æ–¹å‘ã€‚', img: '3.jpg' },
        'è½¦': { emoji: 'ğŸš…', title: 'å¥”èµ´æœªæ¥', text: 'æƒ³å¸¦ä½ åä¸Šé€šå¾€å¹¸ç¦çš„è½¦ï¼Œç»ˆç‚¹ç«™æ˜¯ç™½å¤´å•è€ã€‚', img: '4.jpg' },
        'æˆ¿': { emoji: 'ğŸ ', title: 'é¿é£æ¸¯æ¹¾', text: 'ä¸‡å®¶ç¯ç«ï¼Œæœ‰ä¸€ç›æ˜¯ä¸ºä½ è€Œç•™ï¼Œé‚£ä¾¿æ˜¯å®¶ã€‚', img: '2.jpg' },
        'æ ‘': { emoji: 'ğŸŒ²', title: 'çˆ±å¦‚é•¿é’', text: 'æˆ‘ä»¬çš„æ•…äº‹åƒæ ‘ä¸€æ ·æ‰æ ¹ï¼Œåœ¨å²æœˆé‡Œæç¹å¶èŒ‚ã€‚', img: '1.jpg' },
        'çˆ±å¿ƒ': { emoji: 'â¤ï¸', title: 'æ°¸æ’ä¹‹å¿ƒ', text: 'ä¸‡åƒæ˜Ÿè¾°æ±‡èšï¼Œåªä¸ºæ‹¼å‡‘å‡ºä¸€å¥ï¼šæˆ‘çˆ±ä½ ã€‚', img: '6.jpg' }
    };

    init();
    animate();

    // æ ¸å¿ƒä¼˜åŒ–ï¼šè·å–æ–‡å­—/Emojiçš„åƒç´ ç‚¹é˜µåæ ‡
    function getShapePoints(text, count) {
		const canvas = document.createElement('canvas');
		const ctx = canvas.getContext('2d');
		const size = 128; 
		canvas.width = size; 
		canvas.height = size;

		ctx.fillStyle = 'white';
		ctx.font = '90px Arial';
		ctx.textAlign = 'center';
		ctx.textBaseline = 'middle';
		ctx.fillText(text, size/2, size/2);
		
		const imageData = ctx.getImageData(0, 0, size, size).data;
		const edgePoints = [];   // è¾¹ç¼˜ç‚¹ï¼ˆç»†èŠ‚å…³é”®ï¼‰
		const interiorPoints = []; // å†…éƒ¨ç‚¹

		// 1. æ‰«æåƒç´ ï¼ŒåŒºåˆ†è¾¹ç¼˜å’Œå†…éƒ¨
		for (let y = 1; y < size - 1; y++) {
			for (let x = 1; x < size - 1; x++) {
				const idx = (y * size + x) * 4;
				if (imageData[idx + 3] > 128) { // å¦‚æœæ˜¯å®å¿ƒéƒ¨åˆ†
					// æ£€æŸ¥å››å‘¨æ˜¯å¦æœ‰é€æ˜åƒç´ ï¼Œå¦‚æœæœ‰ï¼Œè¯´æ˜è¿™æ˜¯è¾¹ç¼˜
					const isEdge = 
						imageData[((y-1)*size + x)*4 + 3] <= 128 ||
						imageData[((y+1)*size + x)*4 + 3] <= 128 ||
						imageData[(y*size + (x-1))*4 + 3] <= 128 ||
						imageData[(y*size + (x+1))*4 + 3] <= 128;

					const pt = { 
						x: (x - size/2) / (size/4), 
						y: (size/2 - y) / (size/4) 
					};

					if (isEdge) {
						edgePoints.push(pt);
					} else {
						interiorPoints.push(pt);
					}
				}
			}
		}

		const finalPoints = [];
		
		// 2. ç­–ç•¥æ€§åˆ†é…ç²’å­
		// ä¼˜å…ˆä¿è¯è¾¹ç¼˜æœ‰è¶³å¤Ÿçš„ç²’å­ï¼ˆå  60%-70%ï¼‰ï¼Œè¿™æ ·è½®å»“å’Œçª—æˆ·å­”æ´æ‰ä¼šæ¸…æ™°
		const edgeCount = Math.floor(count * 0.7);
		const interiorCount = count - edgeCount;

		// é‡‡æ ·è¾¹ç¼˜
		for (let i = 0; i < edgeCount; i++) {
			const p = edgePoints[Math.floor(Math.random() * edgePoints.length)];
			if(p) finalPoints.push({
				x: p.x + (Math.random()-0.5)*0.01, // æå°åç§»ï¼Œä¿æŒçº¿æ¡é”åˆ©
				y: p.y + (Math.random()-0.5)*0.01
			});
		}

		// é‡‡æ ·å†…éƒ¨ï¼ˆåŠ å…¥éšæœºç¨€ç–æ„Ÿï¼Œé˜²æ­¢å¡«æ­»ï¼‰
		for (let i = 0; i < interiorCount; i++) {
			const p = interiorPoints[Math.floor(Math.random() * interiorPoints.length)];
			if(p) finalPoints.push({
				x: p.x + (Math.random()-0.5)*0.03,
				y: p.y + (Math.random()-0.5)*0.03
			});
		}

		// è¡¥é½
		while(finalPoints.length < count) finalPoints.push({x:0, y:0});
		return finalPoints;
	}

    function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 6;

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // èƒŒæ™¯æ˜Ÿç©º
        const starGeo = new THREE.BufferGeometry();
        const starPos = new Float32Array(4000 * 3);
        for(let i=0; i<12000; i++) starPos[i] = (Math.random() - 0.5) * 150;
        starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        scene.add(new THREE.Points(starGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.03 })));

        // 1. ç”Ÿæˆæ ¸å¿ƒæ˜Ÿçƒä½ç½®ï¼ˆéšæœºæ€§åˆ†å¸ƒï¼‰
        for (let i = 0; i < particleCount; i++) {
            currentPositions[i*3] = 0; currentPositions[i*3+1] = 0; currentPositions[i*3+2] = 0;
            const radius = 2 + Math.random() * 0.3;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            targetPositions[i*3] = radius * Math.sin(phi) * Math.cos(theta);
            targetPositions[i*3+1] = radius * Math.sin(phi) * Math.sin(theta);
            targetPositions[i*3+2] = radius * Math.cos(phi);
        }

        // 2. ä¼˜åŒ–ç‰¹æ®Šç°‡ï¼šè¿˜åŸ3Dè½®å»“
        const keys = Object.keys(contentData);
        keys.forEach((key, index) => {
            const emoji = contentData[key].emoji;
            const shapePoints = getShapePoints(emoji, 600); // æ¯ä¸ªç‰©ä»¶åˆ†é…600ä¸ªç²’å­
            const startIdx = (particleCount - 4000) + (index * 600);
            
            // è®¡ç®—ç°‡åœ¨çƒé¢çš„ä¸­å¿ƒä½ç½®
            const center = new THREE.Vector3().setFromSphericalCoords(2.2, Math.PI * 0.3 + (index * 1.0), index * 1.2);
            
            // äº¤äº’æ„Ÿåº”å™¨
            const sensor = new THREE.Mesh(new THREE.SphereGeometry(0.5, 8, 8), new THREE.MeshBasicMaterial({ visible: false }));
            sensor.position.copy(center);
            sensor.userData = { name: key };
            group.add(sensor);

            // å°†ç²’å­å¯¹é½åˆ°Emojiè½®å»“
            shapePoints.forEach((p, j) => {
                const pIdx = (startIdx + j) * 3;
                // å°†2Dç‚¹é˜µæ˜ å°„åˆ°3Dç©ºé—´ï¼Œå¹¶æœå‘çƒå¿ƒå¤–ä¾§
                const v = new THREE.Vector3(p.x * 0.4, p.y * 0.4, 0);
                v.applyQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), center.clone().normalize()));
                
                targetPositions[pIdx] = center.x + v.x;
                targetPositions[pIdx+1] = center.y + v.y;
                targetPositions[pIdx+2] = center.z + v.z;
            });
        });

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(currentPositions, 3));
        const material = new THREE.PointsMaterial({ 
            color: 0xffb6c1, size: 0.018, transparent: true, opacity: 0.85, blending: THREE.AdditiveBlending 
        });
        particles = new THREE.Points(geometry, material);
        group.add(particles);
        scene.add(group);

        // äº‹ä»¶ç›‘å¬
        window.addEventListener('resize', onWindowResize);
        document.getElementById('start-btn').addEventListener('click', start);
        renderer.domElement.addEventListener('click', handleInteraction);
        setupControls();
    }

    function start() {
        document.getElementById('cover').style.opacity = '0';
        setTimeout(() => {
            document.getElementById('cover').style.display = 'none';
            const pos = particles.geometry.attributes.position.array;
            for(let i=0; i<particleCount*3; i++) pos[i] = (Math.random()-0.5)*15; // ç‚¸è£‚
            isStarted = true;
        }, 1200);
    }

    function handleInteraction(e) {
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const hits = raycaster.intersectObjects(group.children);
        const hit = hits.find(h => h.object.userData.name);
        if(hit) {
            const data = contentData[hit.object.userData.name];
            document.getElementById('modal-title').innerText = data.emoji + " " + data.title;
            document.getElementById('modal-text').innerText = data.text;
            const img = document.getElementById('modal-img');
            img.src = data.img; img.style.display = data.img ? 'block' : 'none';
            document.getElementById('modal').classList.add('active');
        }
    }

    window.closeModal = () => document.getElementById('modal').classList.remove('active');

    function setupControls() {
        let isDragging = false, px = 0, py = 0;
        const down = (e) => { isDragging = true; const t = e.touches?.[0] || e; px = t.clientX; py = t.clientY; };
        const move = (e) => {
            if(!isDragging) return;
            const t = e.touches?.[0] || e;
            group.rotation.y += (t.clientX - px) * 0.008;
            group.rotation.x += (t.clientY - py) * 0.008;
            px = t.clientX; py = t.clientY;
        };
        const up = () => isDragging = false;
        renderer.domElement.addEventListener('mousedown', down);
        renderer.domElement.addEventListener('touchstart', down);
        window.addEventListener('mousemove', move);
        window.addEventListener('touchmove', move);
        window.addEventListener('mouseup', up);
        window.addEventListener('touchend', up);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        if(isStarted) {
            const pos = particles.geometry.attributes.position.array;
            for(let i=0; i<particleCount*3; i++) {
                pos[i] += (targetPositions[i] - pos[i]) * 0.07; // æ±‡èšåŠ¨ç”»
            }
            particles.geometry.attributes.position.needsUpdate = true;
            group.rotation.y += 0.0012;
        }
        renderer.render(scene, camera);
    }
</script>
</body>
</html>
